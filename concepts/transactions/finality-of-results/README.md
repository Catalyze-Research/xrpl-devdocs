# 결과의 불변성(Finality of Results)

트랜잭션이 컨센서스 ledger에 적용되는 순서는 ledger가 닫히고 정확한 트랜잭션 세트가 [컨센서스 과정](../../consensus-protocol/consensus-structure.md)에 의해 승인될 때까지 확정되지 않습니다. 초기에 성공했던 트랜잭션은 실패할 수 있으며, 초기에 실패했던 트랜잭션은 성공할 수 있습니다. 또한, 한 라운드에서 컨센서스 과정에 의해 거부된 트랜잭션은 나중에 컨센서스를 이룰 수 있습니다.

검증된 ledger에는 성공한 트랜잭션(<mark style="background-color:yellow;">tes</mark> 결과 코드)과 실패한 트랜잭션(<mark style="background-color:yellow;">tec</mark> 결과 코드)이 포함될 수 있습니다. 다른 결과를 가진 트랜잭션은 ledger에 포함되지 않습니다.

다른 결과 코드에 대해서는 결과가 최종인지 판단하기 어려울 수 있습니다. 다음 표는 트랜잭션 제출 결과 코드에 기반한 트랜잭션 결과의 최종성을 요약한 것입니다:

| 결과 코드           | 최종성                                                                                                      |
| --------------- | -------------------------------------------------------------------------------------------------------- |
| `tesSUCCESS`    | 검증된 ledger에 포함될 때 최종                                                                                     |
| 모든 `tec` 코드     | 검증된 ledger에 포함될 때 최종                                                                                     |
| 모든 `tem` 코드     | 프로토콜 변경으로 트랜잭션이 유효해질 때까지 최종이 아님                                                                          |
| `tefPAST_SEQ`   | 동일한 시퀀스 번호를 가진 다른 트랜잭션이 검증된 ledger에 포함될 때 최종                                                             |
| `tefMAX_LEDGER` | 유효성 검사된 ledger가 트랜잭션의 LastRedgerSequence 필드보다 높은 ledger 인덱스를 가지고 있고 트랜잭션을 포함하는 유효성 검사된 ledger가 없는 경우 최종. |

그 외의 다른 트랜잭션 결과는 최종이 아닐 수 있습니다. 이 경우, 트랜잭션이 나중에 성공하거나 실패할 수 있습니다, 특히 트랜잭션이 적용되는 것을 방지하는 상황이 변한 경우에는 그렇습니다. 예를 들어, 아직 존재하지 않는 계정에 비-XRP 화폐를 보내려고 하면 실패하지만, 다른 트랜잭션이 충분한 XRP를 보내 목적지 계정을 생성하면 성공할 수 있습니다. 서버는 일시적으로 실패한 서명된 트랜잭션을 저장하고 나중에 묻지 않고 성공적으로 적용할 수도 있습니다.

## 비최종 결과는 어떻게 바뀔 수 있나요? (How can non-final results change?)

트랜잭션을 처음 제출할 때, <mark style="background-color:yellow;">rippled</mark> 서버는 그 트랜잭션을 현재 열려 있는 ledger에 임시적으로 적용한 후 그 결과를 반환합니다. 그러나 [트랜잭션의 최종 결과](../../../references/xrp-ledger-xrp-ledger-protocol-reference/transaction-reference/transaction-results/)는 그 임시 결과와 매우 다를 수 있습니다. 그 이유는 여러 가지입니다:

* 트랜잭션은 나중의 ledger 버전까지 지연될 수 있거나, 검증된 ledger에 포함되지 않을 수도 있습니다. 대부분, XRP Ledger는 모든 유효한 트랜잭션이 가능한 한 빨리 처리되어야 한다는 원칙을 따릅니다. 그러나 예외 상황도 있습니다:
  * 제안된 트랜잭션이 [컨센서스 라운드](../../consensus-protocol/consensus-structure.md)가 시작될 때까지 대다수의 검증자에게 중계되지 않았다면, 남은 검증자들이 트랜잭션을 가져와 유효한지 확인하는 시간을 주기 위해 다음 ledger 버전까지 연기될 수 있습니다.
  * 어떤 주소가 같은 시퀀스 번호를 사용하여 두 가지 다른 트랜잭션을 보낸다면, 그 트랜잭션들 중 최대 하나만 검증될 수 있습니다. 이런 트랜잭션이 네트워크를 통해 다른 경로로 중계되면, 일부 서버에서는 일시적으로 성공한 트랜잭션이 실패할 수 있습니다. 왜냐하면 다른, 충돌하는 트랜잭션이 먼저 대다수의 서버에 도달했기 때문입니다.
  * 스팸으로부터 네트워크를 보호하기 위해, 모든 트랜잭션은 XRP Ledger P2P 네트워크 전체에 중계되기 위해 XRP의 [트랜잭션 비용](../transaction-cost.md)을 소멸시켜야 합니다. P2P 네트워크에 과부하가 발생하여 트랜잭션 비용이 증가하면, 일시적으로 성공한 트랜잭션이 컨센서스를 이루기 위해 충분한 서버에 중계되지 않거나, 나중에 [대기열](../transaction-queue.md)에 들어갈 수 있습니다.
  * 일시적인 인터넷 중단이나 지연이 제안된 트랜잭션이 트랜잭션의 예정된 만료일 이전에 성공적으로 중계되는 것을 방해할 수 있습니다. 이것은 <mark style="background-color:yellow;">LastLedgerSequence</mark> 필드에 의해 설정됩니다. (트랜잭션에 만료일이 없다면, 그것은 유효하며 언제든지 성공할 수 있습니다. 이는 자체적으로 바람직하지 않을 수 있습니다. [신뢰할 수 있는 트랜잭션 제출](../reliable-transaction-submission.md)에 대한 자세한 내용을 참조하십시오.)
  * 두 가지 이상의 요인이 결합해서 일어날 수도 있습니다.&#x20;
* [닫힌 ledger에 적용된 트랜잭션의 순서](../../undefined-1/ledgers.md)는 일반적으로 현재 열려 있는 ledger에 임시적으로 적용된 트랜잭션의 순서와 다릅니다. 트랜잭션에 따라, 일시적으로 성공했던 트랜잭션이 실패할 수 있고, 일시적으로 실패했던 트랜잭션이 성공할 수 있습니다. 몇 가지 예는 다음과 같습니다:
  * 두 개의 트랜잭션이 각각 탈중앙화 거래에서 같은 제안을 완전히 소비하려고 한다면, 먼저 온 트랜잭션이 성공하고, 다른 트랜잭션은 실패합니다. 적용되는 트랜잭션의 순서가 바뀔 수 있으므로, 성공했던 트랜잭션이 실패하고, 실패했던 트랜잭션이 성공할 수 있습니다. 제안이 부분적으로 실행될 수 있으므로, 그들은 더 크거나 더 작은 범위로 여전히 성공할 수 있습니다.
  * [교차 화폐 결제](../../undefined-1/undefined.md)가 탈중앙화 거래의 제안을 소비하여 성공했지만, 다른 트랜잭션이 같은 오더북에서 제안을 소비하거나 생성하면, 교차 화폐 결제는 처음에 예상했던 것보다 다른 환율로 성공할 수 있습니다. 부분 결제인 경우, 다른 금액을 전달할 수도 있습니다.
  * 송신자가 충분한 자금을 갖고 있지 않아 일시적으로 실패한 [결제 트랜잭션](../../../references/xrp-ledger-xrp-ledger-protocol-reference/transaction-reference/transaction-types/payment.md)은 필요한 자금을 전달하는 다른 트랜잭션이 표준 순서에 따라 먼저 온 경우 나중에 성공할 수 있습니다. 그 반대의 경우도 가능합니다. 필요한 자금을 전달하는 거래가 표준적인 순서로 정렬된 후에 우선되지 않았기 때문에 잠정적으로 성공한 거래가 실패할 수 있습니다.

{% hint style="info" %}
Tip:

이러한 이유로, XRP Ledger에 대해 테스트를 실행할 때 동일한 데이터에 영향을 미치는 여러 계정이 있는 경우 트랜잭션 사이에 가까운 ledger 기다려야 합니다. stand-alone 모드에서 서버에 대해 테스트하는 경우, 이러한 경우 수동으로 ledger를 닫아야 합니다.
{% endhint %}

### 참고 <a href="#see-also" id="see-also"></a>

* [Look up Transaction Results](https://xrpl.org/look-up-transaction-results.html)
* [Transaction Results Reference](https://xrpl.org/transaction-results.html)
