# 트랜잭션 변조 가능성

트랜잭션이 서명된 후에는 해당 트랜잭션의 키 없이 어떤 방식으로든 변경될 수 있다면 해당 트랜잭션은 "변조 가능"하다고 합니다. XRP Ledger에서는 서명된 트랜잭션의 **기능**이 변경되지 않습니다. 그러나 특정 상황에서 제3자가 트랜잭션의 서명 및 식별 해시를 변경할 _수_ 있습니다.

약점이 있는 소프트웨어가 변조 가능한 트랜잭션을 제출하고 해당 트랜잭션이 원래의 해시 아래에서만 실행될 수 있다고 가정한다면, 시스템은 트랜잭션을 추적하지 못할 수 있습니다. 최악의 경우, 악의적인 사용자는 이를 악용하여 취약한 시스템으로부터 자금을 도난할 수 있습니다.

XRP Ledger의 메인넷에서는 **다중 서명 트랜잭션**이 변조 가능할 수 있습니다. 이는 필요한 서명보다 많은 서명이 있는 경우나 권한이 있는 서명자가 필요 이상의 서명을 제공하는 경우에 해당됩니다. 우수한 운영 보안은 이러한 문제에 대해 보호해 줄 수 있습니다. 지침은 [다중 서명의 변조 가능성에 대한 완화책](undefined-6.md#undefined-2) 문서에서 확인할 수 있습니다.

2014년 이전까지는 기본 서명 알고리즘인 secp256k1 곡선을 사용하는 ECDSA로 인해 단일 서명 트랜잭션도 변조 가능할 수 있었습니다. 호환성을 위해 [RequireFullyCanonicalSig 수정안](../xrp-ledger/undefined-2/undefined.md)이 2020년 7월 3일에 활성화될 때까지 변조 가능한 단일 서명 트랜잭션을 생성하고 제출할 수 있었습니다. ([Ed25519 키로 서명](../undefined-1/undefined/undefined.md)된 트랜잭션은 이러한 문제에 대해 항상 취약하지 않았습니다.)

## 배경&#x20;

XRP Ledger에서 트랜잭션이 실행되기 위해서는 다음과 같은 조건을 충족해야 합니다:

* 서명을 제외한 [트랜잭션의 모든 필드](../../references/xrp-ledger/undefined-1/undefined.md)가 서명되어야 합니다.&#x20;
* 트랜잭션에 사용된 키 쌍은 해당 계정을 대신하여[ 트랜잭션을 보낼 권한이 있어야 합니다.](../undefined-1/undefined-2/)&#x20;
* 서명은 규범적이며 트랜잭션의 명령어와 일치해야 합니다.&#x20;

서명이 포함된 필드에 어떤 변경이 있더라도 서명이 무효화되므로, 서명 자체를 제외한 트랜잭션의 어떤 부분도 변조 가능하지 않습니다. 대부분의 경우, 서명 자체에 대한 변경도 서명을 무효화시키지만, 특정한 예외 사항이 있습니다. 이에 대한 설명은 아래에서 제시합니다.

서명은 트랜잭션의 식별 해시를 계산하는 데 사용되는 데이터 중 하나이므로, 변조 가능한 트랜잭션의 어떤 변경이든 다른 해시를 생성합니다.

## 대체 secp256k1 서명&#x20;

"규범적"인 ECDSA 알고리즘과 secp256k1 곡선(기본값)을 사용하여 생성된 서명은 다음 요구 사항을 충족해야 합니다:

* 서명은 올바르게 [DER로 인코딩](https://en.wikipedia.org/wiki/X.690#DER\_encoding)된 데이터여야 합니다.&#x20;
* 서명은 DER로 인코딩된 데이터 외에 어떤 채움 바이트도 포함해서는 안 됩니다.&#x20;
* 서명의 구성 정수는 음수일 수 없으며, secp256k1 그룹 순서보다 크지 않아야 합니다.&#x20;

일반적으로 표준 ECDSA 구현은 이러한 요구 사항을 자동으로 처리합니다. 그러나 secp256k1에서는 이러한 요구 사항이 변조 가능성을 방지하기에 충분하지 않습니다. 따라서 XRP Ledger에는 이러한 문제가 없는 "완전 규범적" 서명 개념이 있습니다.

ECDSA 서명은 R과 S라는 두 정수로 구성됩니다. secp256k1 그룹 순서인 N은 모든 secp256k1 서명에 대해 상수 값입니다. 구체적으로, N은 <mark style="background-color:yellow;">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</mark>의 값을 가집니다. 주어진 서명 <mark style="background-color:yellow;">(R,S)</mark>에 대해 서명 <mark style="background-color:yellow;">(R, N-S)</mark> (즉, S 대신 N에서 S를 뺀 값을 사용하는 경우)도 유효합니다.

따라서 완전 규범적 서명을 얻기 위해서는 두 가지 가능성 중 어떤 것을 선호하고 다른 것을 무효로 선언해야 합니다. XRP Ledger의 개발자들은 임의로 S와 N-S 중 더 작은 값을 선호하는 방향으로 결정했습니다. 트랜잭션은 선호되는(S가 더 작은) S 값으로 완전 규범적인 경우로 간주되며, 규범적인 트랜잭션에 필요한 모든 일반적인 규칙을 따릅니다. 완전 규범적인 ECDSA 서명을 계산하려면 <mark style="background-color:yellow;">S</mark>와 <mark style="background-color:yellow;">N-S</mark>를 비교하여 작은 값으로 사용해야 합니다.

RequireFullyCanonicalSig 개선안이 활성화되면(2020년) 모든 트랜잭션은 완전 규범적인 서명만 사용해야 합니다.

2014년부터 2020년까지, XRP Ledger는 완전 규범적 서명을 항상 생성하지 않는 기존 소프트웨어와 호환성이 있었으며, 이러한 문제에 대해 호환성 있는 서명 소프트웨어를 보호하기 위해 [<mark style="background-color:yellow;">**tfFullyCanonicalSig**</mark>](../../references/xrp-ledger/undefined-1/undefined.md) 플래그를 사용했습니다. 호환 가능한 서명 소프트웨어는 기본적으로 이 플래그를 활성화하며, 트랜잭션이 유효하려면 완전 규범적인 서명을 사용해야 했습니다. [RequireFullyCanonicalSig 수정안](../xrp-ledger/undefined-2/)이 활성화된 이후로는 이 플래그는 더 이상 필요하지 않지만, 그래도 활성화하는 데는 해가 없습니다.

## 다중 서명과의 변조 가능성&#x20;

다중 서명의 중요한 명시적인 특징은 여러 다른 구성이 트랜잭션을 유효하게 만들 수 있다는 것입니다. 예를 들어, 계정은 5명의 서명자 중 3명의 서명만 허용하여 트랜잭션을 승인할 수 있도록 구성될 수 있습니다. 그러나 이는 트랜잭션의 여러 가지 유효한 변형이 가능하다는 것을 의미합니다. 각 변형은 서로 다른 식별 해시를 가지게 됩니다.

다음의 모든 경우에서 트랜잭션 변조 가능성이 발생할 수 있습니다:

* 하나 이상의 서명을 제거하여 트랜잭션의 쿼럼을 충족시킬 수 있는 경우. 제3자는 서명을 제거하고 해당 트랜잭션을 다시 제출할 수 있습니다.&#x20;
* 이미 쿼럼을 충족하는 트랜잭션에 유효한 서명을 추가할 수 있는 경우. 송신자의 다중 서명 설정에 따라, 이는 트랜잭션에 기존 서명을 제거하거나 추가하는 것과 관련될 수 있습니다.&#x20;
* 트랜잭션의 서명 중 하나를 다른 유효한 서명으로 바꿀 수 있는 경우. 송신자의 다중 서명 설정에 따라, 이는 트랜잭션에 새로운 서명을 추가하거나 기존 서명을 교체하는 것과 관련될 수 있습니다.&#x20;

권한 있는 서명자가 악의적이지 않더라도 혼란이나 미흡한 조율로 인해 여러 서명자가 동일한 트랜잭션의 서로 다른 유효한 버전을 제출할 수 있습니다.

## 다중 서명의 변조 가능성에 대한 완화책&#x20;

**좋은 운영 보안은 이러한 문제에 대해 보호할 수 있습니다.** 다중 서명의 경우, 다음과 같은 좋은 운영 보안 관행을 따른다면 변조 가능성 문제를 피할 수 있습니다:

* 필요한 서명보다 많은 서명을 수집하지 않습니다.&#x20;
* 필요한 서명 수집 후에는 트랜잭션을 조립하는 한 당사자를 지정하거나, 서명자에게 트랜잭션 명령어를 일렬로 전달하도록 지시합니다.&#x20;
* 불필요한 또는 신뢰할 수 없는 서명자를 다중 서명 목록에 추가하지 않습니다. 그들의 키에 연결된 <mark style="background-color:yellow;">가중치</mark> 값이 트랜잭션을 승인하기에 부족하더라도 추가하지 않습니다.&#x20;
* 트랜잭션의 식별 해시와 서명 집합이 예상과 다른 상태에서 실행될 가능성을 대비합니다. 계정의 전송된 트랜잭션을 주의 깊게 모니터링합니다(예: account\_tx 메소드 사용.)
* 계정의 <mark style="background-color:yellow;">시퀀스</mark> 번호를 모니터링합니다(예: account\_info 메소드 사용.) 이 번호는 계정이 트랜잭션을 성공적으로 전송할 때마다 정확히 1씩 증가하며, 다른 방식으로는 절대로 증가하지 않습니다. 예상한 번호와 일치하지 않는 경우, 최근 트랜잭션을 확인하여 확인해야 합니다(변조 가능한 트랜잭션 외에도 다른 이유로 인해 발생할 수 있습니다. 다른 애플리케이션을 통해 트랜잭션을 보내도록 구성한 경우일 수 있습니다. 악의적인 사용자가 비밀 키에 액세스한 경우일 수 있습니다. 또는 애플리케이션이 데이터를 손실하여 전송한 트랜잭션을 잊어버린 경우일 수 있습니다.)
* 다중 서명을 다시 생성할 때, 의도한 작업이 이미 실행되지 않았음을 수동으로 확인하지 않는 한 <mark style="background-color:yellow;">Sequence</mark> 번호를 변경하지 않습니다.&#x20;
* 서명하기 전에 <mark style="background-color:yellow;">tfFullyCanonicalSig</mark> 플래그가 활성화되어 있는지 확인합니다.&#x20;

보다 높은 보안을 위해 이러한 지침들은 여러 계층의 보호를 제공합니다.

## 트랜잭션 변조를 통한 악용

XRP Ledger와 상호 작용하는 소프트웨어가 변조 가능한 트랜잭션을 전송하는 경우, 악의적인 사용자는 해당 소프트웨어를 속여 트랜잭션의 최종 결과를 추적하지 못하게 하고, 최악의 경우 등가의 지불을 여러 번 보낼 수 있습니다.

단일 서명만 사용하는 경우에는 이러한 악용에 취약하지 않습니다. 다중 서명을 사용하는 경우에는 필요 이상의 서명을 제공하는 경우 취약할 수 있습니다.

## 악용 시나리오 단계&#x20;

취약한 시스템을 악용하는 과정은 다음과 같은 단계로 이루어집니다:

1. 취약한 시스템이 다중 서명 트랜잭션을 구성하고 필요한 이상의 서명을 수집합니다. 권한이 있는 서명자가 악의적이거나 무책임한 경우, 해당 서명자의 서명이 포함되지 않았지만 추가될 수 있기 때문에 트랜잭션도 취약할 수 있습니다.
2. 시스템은 취약한 트랜잭션의 식별 해시를 기록하고, XRP Ledger 네트워크에 제출한 다음, 해당 해시가 유효한 ledger 버전에 포함되기를 모니터링합니다.
3. 악의적인 사용자는 트랜잭션이 네트워크를 통해 전파되는 것을 확인합니다.
4. 악의적인 사용자는 취약한 트랜잭션에서 하나의 추가 서명을 제거합니다.\
   다른 트랜잭션 명령을 위해 서명을 생성하는 것과는 달리, 이 작업은 큰 계산 작업이 필요하지 않습니다. 첫 번째로 서명을 생성하는 것보다 훨씬 짧은 시간에 수행될 수 있습니다.\
   또는 이미 트랜잭션에 포함되지 않은 권한이 있는 서명자가 취약한 트랜잭션의 서명 목록에 자신의 서명을 추가할 수 있습니다. 송신자의 다중 서명 설정에 따라, 다른 서명을 제거하는 대신에도 서명을 추가할 수 있습니다.\
   서명 목록의 수정으로 인해 다른 식별 해시가 생성됩니다. (네트워크에 제출하기 전에 해시를 계산할 필요는 없지만, 나중에 트랜잭션 상태를 확인하기 쉽게 하기 위해 해시를 알고 있는 것이 좋습니다.)
5. 악의적인 사용자는 수정된 트랜잭션을 네트워크에 제출합니다. 이로써 원래 제출된 트랜잭션과 악의적인 사용자가 제출한 수정된 버전 간에 "경주"가 발생합니다. 두 트랜잭션은 상호 배타적입니다. 둘 다 유효하지만, 시퀀스 번호를 포함한 정확히 동일한 트랜잭션 데이터를 가지고 있으므로 최대 한 개의 트랜잭션만 유효한 ledger에 포함될 수 있습니다. P2P 네트워크의 서버는 어떤 트랜잭션이 "먼저" 도착했는지 또는 원래 송신자의 의도였는지 알 수 없습니다. 네트워크 연결의 지연이나 다른 우연한 사건으로 인해 유효성 제안을 최종화할 때 검증기가 둘 중 하나만 볼 수 있으므로 둘 중 하나가 "경주"에서 이기게 될 수 있습니다. 악의적인 사용자는 일부 연결이 우수한 서버를 제어한다면(그 서버가 검증기로서 신뢰받지 않더라도) 비정규적인 트랜잭션을 확인받는 가능성을 높일 수 있습니다. 악의적인 사용자가 취약한 시스템이 트랜잭션을 제출한 유일한 서버를 제어하는 경우, 악의적인 사용자는 어떤 버전이 네트워크 전체로 분산되는지 쉽게 제어할 수 있습니다.
6. 악의적인 사용자의 트랜잭션 버전은 컨센서스를 이루고 유효한 ledger에 포함됩니다.\
   이 시점에서 트랜잭션은 실행되었으며 취소할 수 없습니다. 해당 트랜잭션의 효과(예: XRP 전송)는 최종적입니다. 원래 트랜잭션의 버전은 <mark style="background-color:yellow;">시퀀스</mark> 번호가 사용되었기 때문에 더 이상 유효하지 않습니다.\
   XRP Ledger에서의 트랜잭션의 효과는 원래 버전이 실행된 것과 정확히 동일합니다.
7. 취약한 시스템은 기대하는 트랜잭션 해시를 볼 수 없으며, 잘못된 결론을 내리며 해당 트랜잭션이 실행되지 않았다고 가정합니다.\
   만약 트랜잭션이 <mark style="background-color:yellow;">LastLedgerSequence</mark> 필드를 포함한 경우, 이는 지정된 ledger 인덱스가 지나간 후에 발생합니다.\
   트랜잭션이 <mark style="background-color:yellow;">LastLedgerSequence</mark> 필드를 포함하지 않은 경우, 다른 방식으로 잘못될 수 있습니다: 동일한 송신자에서 동일한 <mark style="background-color:yellow;">시퀀스</mark> 번호를 사용하는 다른 트랜잭션이 없는 경우, 트랜잭션은 이론적으로 얼마나 시간이 지났든 이후에도 성공할 수 있습니다(자세한 내용은 Reliable Transaction Submission을 참조).
8. 취약한 시스템은 트랜잭션이 실패했다고 가정하고 이에 따른 조치를 취합니다.\
   예를 들어, XRP Ledger에 보낸 금액이 전송되지 않은 것으로 생각하여 고객의 잔액을 환불(또는 차감)할 수 있습니다.\
   더 나쁜 경우, 취약한 시스템은 원래 트랜잭션과 동일한 내용을 가진 새로운 트랜잭션을 구성하여 <mark style="background-color:yellow;">시퀀스</mark>, <mark style="background-color:yellow;">LastLedgerSequence</mark> 및 <mark style="background-color:yellow;">수수료</mark> 매개변수를 변경할 수 있습니다. 이 새로운 트랜잭션이 변조 가능하다면 시스템은 동일한 방식으로 계속해서 악용될 수 있습니다.
